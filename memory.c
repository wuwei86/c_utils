/*******************************************************************************************************
* Copyright (c) 2010,深圳市麦格斯科技有限公司终端部
* All rights reserved.
*
* 文件名称  : memory.c
* 摘要      : 内存分配的测试函数
*
* Current Version 1.0--wuwei--2012.08.17
* 描述：创建文件
*******************************************************************************************************
*/


#include "memory.h"


/******************************************************************************************************
内存分为3个部分:
//1.静态区:保存自动全局变量和static的类型变量（包括static的全局变量和局部变量）.静态区的内容在整个程序
		   生命周期内都存在，由编译器在编译的时候分配地址空间。
//2.栈:保存局部变量。栈的内容只在函数的范围内存在,当函数运行完成后自动销毁。其特点是效率高但是空间有限.
//3.堆:有malloc系列函数或new操作分配的内存。其生命周期由free或delete决定。在没有释放之前一直存在，直到
	   程序结束。其特点是使用灵活，空间大，但是很容易出错！
******************************************************************************************************/
int value = 15;

#if 0
/* 没有为指针分配内存的例程(数据结构在memory.h文件中定义) */
char PmemoryTest(void)
{
	pstu = (struct student*)malloc(sizeof(struct student));
	stu.name = (char*)malloc(sizeof(stu.name));//必须给stu.name分配内存空间，否则就会出现错误。
	strcpy(stu.name,"wuwei");
	stu.score = 100;
	printf("%s\n",stu.name);/*运行到此处后会提示内存错误，因为没有给stu.name分配内存空间*/
	//free(stu.name);
	free(pstu);
	return 0;
}
#endif

/* 为指针分配内存测试函数 */
char Pmalloc(void)
{
	char *p1 = "abcdefg";
	char *p2 = (char*)malloc(sizeof(char)*strlen(p1));//strlen(p1)--计算p1的长度即P1有多少个sizeof(char)
	char *p = (char*)malloc(100);
	if(NULL == p2)
	{
		return 1;
	}
	strcpy(p2,p1);
	printf("%s\n",p2);
	free(p2);
	free(p);
	return 0;
}



/***********************************************************************************************************
函数的递归调用

***********************************************************************************************************/
void ResFun(int i)
{
	if(i>0)
	{
		ResFun(i/2);
	}
	printf("%d\n",i);
}


/***********************************************************************************************************
内存对齐问题

***********************************************************************************************************/

void memory(void)
{
	#pragma pack(8) //设定为8字节对齐
	int num = 0;
	typedef struct 
	{
		char a;

		short b;

		char c;

		int d;
	}structTest;

	num = sizeof(structTest);
	printf("%d\n",num);
}

/***********************************************************************************************************
函数返回值得问题
通过下面的例子可以看出局部变量时可以被返回出来的。

***********************************************************************************************************/

char *GetStr(void)
{
	char tmp[4] = "123";
	char *p;
	p = tmp;
	//return tmp;//返回tmp的时候，此时数组tmp为局部变量，存放在栈中，无法返回
	return p;//p此时指向tmp，无法返回。
}

/***********************************************************************************************************
返回全局变量的地址，在另一个文件中就可以获取全局变量的值

***********************************************************************************************************/
int GetVal(void)
{
	return value;
}